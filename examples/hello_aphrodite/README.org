#+TITLE: Hello Aphrodite
#+OPTIONS: toc:nil

* Hello Aphrodite

This example demonstrates the core features of Aphrodite engine, including different rendering approaches, resource loading, and bindless rendering. It renders a textured cube that can be viewed using geometry shading, mesh shading, or bindless mesh shading.

** Features

- *Three Rendering Approaches*:
  - *Geometry Shading*: Traditional vertex/fragment shader pipeline
  - *Mesh Shading*: Advanced rendering using task/mesh shaders
  - *Bindless Mesh Shading*: Mesh shading with automatic handle generation

- *Resource Loading*: Shows how to load vertex buffers, index buffers, textures, and shaders

- *Render Graph*: Demonstrates setting up a render pass with color and depth attachments

- *Runtime Switching*: Press Spacebar to cycle between rendering approaches

** Command Line Usage

You can run the application with the following command line options:

- =--shading-type <type>=: Choose the rendering approach
  - =geometry=: Use geometry shading (vertex/fragment)
  - =mesh=: Use mesh shading (task/mesh/fragment)
  - =mesh_bindless=: Use mesh shading with bindless resources (default)

Example usage:
#+begin_src sh
# Run with geometry shading
./hello_aphrodite --shading-type geometry

# Run with mesh shading
./hello_aphrodite --shading-type mesh

# Run with bindless mesh shading (default)
./hello_aphrodite --shading-type mesh_bindless
#+end_src

** How It Works

The application demonstrates several key Aphrodite engine concepts:

*** Resource Loading System

The example shows how to use the batch loading request system to load:
- Vertex and index buffers for a cube
- Camera MVP uniforms
- Textures and samplers
- Multiple shader programs

*** Render Graph

A simple render graph with a single draw pass that:
1. Sets up color and depth attachments
2. Configures resource inputs and outputs
3. Records command buffer execution

*** Bindless Resources

The bindless system demonstrates how to:
1. Register resources with semantic names
2. Automatically generate shader bindings
3. Access resources in shaders without explicit binding configuration

*** Input Handling

Shows event registration for keyboard events to switch rendering modes at runtime.

** Code Examples

*** Resource Loading

#+BEGIN_SRC cpp
// Create a batch loading request
aph::LoadRequest geometryRequest = m_pResourceLoader->createRequest();

// Create vertex buffer
{
    aph::BufferLoadInfo bufferLoadInfo{
        .debugName = "cube::vertex_buffer",
        .data = vertices.data(),
        .dataSize = vertices.size() * sizeof(vertices[0]),
        .createInfo = {
            .size = vertices.size() * sizeof(vertices[0]),
            .usage = aph::BufferUsage::Storage | aph::BufferUsage::Vertex,
            .domain = aph::MemoryDomain::Device,
        },
        .contentType = aph::BufferContentType::Vertex
    };

    geometryRequest.add(bufferLoadInfo, &m_pVertexBuffer);
}

// Create index buffer
{
    aph::BufferLoadInfo bufferLoadInfo{
        .debugName = "cube::index_buffer",
        .data = indices.data(),
        .dataSize = indices.size() * sizeof(indices[0]),
        .createInfo = {
            .size = indices.size() * sizeof(indices[0]),
            .usage = aph::BufferUsage::Storage | aph::BufferUsage::Index,
            .domain = aph::MemoryDomain::Device,
        },
        .contentType = aph::BufferContentType::Index
    };

    geometryRequest.add(bufferLoadInfo, &m_pIndexBuffer);
}

// Create uniform buffer for matrices
{
    aph::BufferLoadInfo bufferLoadInfo{
        .debugName = "matrix data",
        .data = &m_mvp,
        .dataSize = sizeof(m_mvp),
        .createInfo = {
            .size = sizeof(m_mvp),
            .usage = aph::BufferUsage::Uniform,
            .domain = aph::MemoryDomain::Host,
        },
        .contentType = aph::BufferContentType::Uniform
    };
    
    geometryRequest.add(bufferLoadInfo, &m_pMatrixBffer);
}

// Create sampler and load texture
{
    // Create a linear clamp sampler
    m_pSampler = m_pDevice->create(aph::vk::SamplerCreateInfo{}.preset(aph::SamplerPreset::LinearClamp));
    
    // Load container texture
    aph::ImageLoadInfo imageLoadInfo{
        .debugName = "container texture",
        .data = "texture://container2.png",
        .createInfo = {
            .usage = aph::ImageUsage::Sampled,
            .domain = aph::MemoryDomain::Device,
            .imageType = aph::ImageType::e2D,
        },
        .featureFlags = aph::ImageFeatureBits::GenerateMips
    };

    geometryRequest.add(imageLoadInfo, &m_pImageAsset);
}

// Execute all geometry resource loads
geometryRequest.load();

// -------- Load shader programs --------
aph::LoadRequest shaderRequest = m_pResourceLoader->createRequest();

// Load bindless mesh shading program
{
    // Register resources with the bindless system
    auto bindless = m_pDevice->getBindlessResource();
    bindless->updateResource(m_pImageAsset->getImage(), "texture_container");
    bindless->updateResource(m_pSampler, "samp");
    bindless->updateResource(m_pMatrixBffer->getBuffer(), "transform_cube");
    bindless->updateResource(m_pVertexBuffer->getBuffer(), "vertex_cube");
    bindless->updateResource(m_pIndexBuffer->getBuffer(), "index_cube");

    // Load shader with bindless resources
    aph::ShaderLoadInfo shaderLoadInfo{
        .debugName = "ts + ms + fs (bindless)",
        .data = {"shader_slang://hello_mesh_bindless.slang"},
        .stageInfo = {
            {aph::ShaderStage::TS, "taskMain"},
            {aph::ShaderStage::MS, "meshMain"},
            {aph::ShaderStage::FS, "fragMain"},
        },
        .pBindlessResource = bindless
    };
    
    shaderRequest.add(shaderLoadInfo, &m_pProgram);
}

// Execute all shader loads
shaderRequest.load();
#+END_SRC

*** Frame Graph Setup

#+BEGIN_SRC cpp
// Setup the render graph for each frame resource
for (auto* graph : m_pEngine->setupGraph())
{
    // Create descriptions for color and depth attachments
    aph::vk::ImageCreateInfo renderTargetColorInfo{
        .extent = {m_pSwapChain->getWidth(), m_pSwapChain->getHeight(), 1},
        .format = m_pSwapChain->getFormat(),
    };

    aph::vk::ImageCreateInfo renderTargetDepthInfo{
        .extent = {m_pSwapChain->getWidth(), m_pSwapChain->getHeight(), 1},
        .format = aph::Format::D32,
    };

    // Create a render pass group for main rendering
    auto renderGroup = graph->createPassGroup("MainRender");

    // Create and configure drawing pass using the builder pattern
    auto* drawPass = renderGroup.addPass("drawing cube", aph::QueueType::Graphics);
    drawPass->configure()
        .colorOutput("render output", {.createInfo = renderTargetColorInfo})
        .depthOutput("depth buffer", {.createInfo = renderTargetDepthInfo})
        .textureInput("container texture", m_pImageAsset->getImage())
        .bufferInput("matrix ubo", m_pMatrixBffer->getBuffer(), aph::BufferUsage::Uniform)
        .build();

    // Create UI pass
    auto* uiPass = graph->createPass("drawing ui", aph::QueueType::Graphics);
    uiPass->configure()
        .colorOutput("render output", {.createInfo = renderTargetColorInfo,
                                        .attachmentInfo = {
                                            .loadOp = aph::AttachmentLoadOp::DontCare,
                                        }})
        .build();

    // Set the output buffer for display
    graph->setBackBuffer("render output");
}
#+END_SRC

*** Render Loop

#+BEGIN_SRC cpp
// Use coroutine-based frame loop
for (auto frameResource : m_pEngine->loop())
{
    APH_PROFILER_FRAME("application loop");
    
    // Scene updates (transformations, animations)
    m_mvp.model = aph::Rotate(m_mvp.model, (float)m_pEngine->getCPUFrameTime(), {0.5f, 1.0f, 0.0f});
    
    // GPU resource updates (uniforms, textures)
    m_pResourceLoader->update({.data = &m_mvp, .range = {0, sizeof(m_mvp)}}, m_pMatrixBffer);
    
    // Build this frame's render graph
    buildGraph(frameResource.pGraph);  
}
#+END_SRC

*** Command Buffer Recording

#+BEGIN_SRC cpp
void buildGraph(aph::RenderGraph* pGraph)
{
    auto drawPass = pGraph->getPass("drawing cube");
    drawPass->recordExecute(
        [this](auto* pCmd)
        {
            // Set common depth test settings
            pCmd->setDepthState({
                .enable = true,
                .write = true,
                .compareOp = aph::CompareOp::Less,
            });

            pCmd->beginDebugLabel({
                .name = "mesh shading path (bindless)",
                .color = {0.5f, 0.3f, 0.2f, 1.0f},
            });

            pCmd->setProgram(m_pProgram->getProgram());
            pCmd->draw(aph::DispatchArguments{1, 1, 1});

            pCmd->endDebugLabel();
        });

    auto uiPass = pGraph->getPass("drawing ui");
        
    uiPass->recordExecute(
        [this](auto* pCmd)
        {
            auto* ui = m_pEngine->getUI();
            ui->beginFrame();
            ui->render(pCmd);
            ui->endFrame();
        });

    pGraph->build(m_pSwapChain);
}
#+END_SRC

*** Bindless Resources

#+BEGIN_SRC cpp
// Register resources with the bindless system
auto bindless = m_pDevice->getBindlessResource();
bindless->updateResource(m_pImageAsset->getImage(), "texture_container");
bindless->updateResource(m_pSampler, "samp");
bindless->updateResource(m_pMatrixBffer->getBuffer(), "transform_cube");
bindless->updateResource(m_pVertexBuffer->getBuffer(), "vertex_cube");
bindless->updateResource(m_pIndexBuffer->getBuffer(), "index_cube");

// Load shader with bindless support
aph::ShaderLoadInfo shaderLoadInfo{ 
    .debugName = "ts + ms + fs (bindless)",
    .data = {"shader_slang://hello_mesh_bindless.slang"},
    .stageInfo = {
        {aph::ShaderStage::TS, "taskMain"},
        {aph::ShaderStage::MS, "meshMain"},
        {aph::ShaderStage::FS, "fragMain"},
    },
    .pBindlessResource = bindless
};

shaderRequest.add(shaderLoadInfo, &m_pProgram);
#+END_SRC

*** Application Setup

#+BEGIN_SRC cpp
int main(int argc, char** argv)
{
    HelloAphrodite app{};

    auto result =
        app.getOptions()
            .setVsync(false)
            .parse(argc, argv);

    APH_VERIFY_RESULT(result);
    app.run();
}
#+END_SRC
